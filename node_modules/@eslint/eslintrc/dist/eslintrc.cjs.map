{"version":3,"file":"eslintrc.cjs","sources":["../lib/config-array/ignore-pattern.js","../lib/config-array/extracted-config.js","../lib/config-array/config-array.js","../lib/config-array/config-dependency.js","../lib/config-array/override-tester.js","../lib/config-array/index.js","../lib/shared/config-ops.js","../lib/shared/deprecation-warnings.js","../lib/shared/ajv.js","../conf/config-schema.js","../conf/environments.js","../lib/shared/config-validator.js","../lib/shared/naming.js","../lib/shared/relative-module-resolver.js","../lib/config-array-factory.js","../lib/cascading-config-array-factory.js","../lib/flat-compat.js","../lib/index.js"],"sourcesContent":["/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport assert from \"assert\";\nimport path from \"path\";\nimport ignore from \"ignore\";\nimport debugOrig from \"debug\";\n\nconst debug = debugOrig(\"eslintrc:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n    let result = sourcePaths[0];\n\n    for (let i = 1; i < sourcePaths.length; ++i) {\n        const a = result;\n        const b = sourcePaths[i];\n\n        // Set the shorter one (it's the common ancestor if one includes the other).\n        result = a.length < b.length ? a : b;\n\n        // Set the common ancestor.\n        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n            if (a[j] !== b[j]) {\n                result = a.slice(0, lastSepPos);\n                break;\n            }\n            if (a[j] === path.sep) {\n                lastSepPos = j;\n            }\n        }\n    }\n\n    let resolvedResult = result || path.sep;\n\n    // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n    if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n        resolvedResult += path.sep;\n    }\n    return resolvedResult;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n    const relPath = path.relative(from, to);\n\n    if (path.sep === \"/\") {\n        return relPath;\n    }\n    return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n    const isDir = (\n        filePath.endsWith(path.sep) ||\n        (process.platform === \"win32\" && filePath.endsWith(\"/\"))\n    );\n\n    return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n\n    /**\n     * The default patterns.\n     * @type {string[]}\n     */\n    static get DefaultPatterns() {\n        return DefaultPatterns;\n    }\n\n    /**\n     * Create the default predicate function.\n     * @param {string} cwd The current working directory.\n     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createDefaultIgnore(cwd) {\n        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n    }\n\n    /**\n     * Create the predicate function from multiple `IgnorePattern` objects.\n     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createIgnore(ignorePatterns) {\n        debug(\"Create with: %o\", ignorePatterns);\n\n        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n        const patterns = [].concat(\n            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))\n        );\n        const ig = ignore().add([...DotPatterns, ...patterns]);\n        const dotIg = ignore().add(patterns);\n\n        debug(\"  processed: %o\", { basePath, patterns });\n\n        return Object.assign(\n            (filePath, dot = false) => {\n                assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n                const relPathRaw = relative(basePath, filePath);\n                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));\n                const adoptedIg = dot ? dotIg : ig;\n                const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n\n                debug(\"Check\", { filePath, dot, relativePath: relPath, result });\n                return result;\n            },\n            { basePath, patterns }\n        );\n    }\n\n    /**\n     * Initialize a new `IgnorePattern` instance.\n     * @param {string[]} patterns The glob patterns that ignore to lint.\n     * @param {string} basePath The base path of `patterns`.\n     */\n    constructor(patterns, basePath) {\n        assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {string[]}\n         */\n        this.patterns = patterns;\n\n        /**\n         * The base path of `patterns`.\n         * @type {string}\n         */\n        this.basePath = basePath;\n\n        /**\n         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n         *\n         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n         * It's `false` as-is for `ignorePatterns` property in config files.\n         * @type {boolean}\n         */\n        this.loose = false;\n    }\n\n    /**\n     * Get `patterns` as modified for a given base path. It modifies the\n     * absolute paths in the patterns as prepending the difference of two base\n     * paths.\n     * @param {string} newBasePath The base path.\n     * @returns {string[]} Modifired patterns.\n     */\n    getPatternsRelativeTo(newBasePath) {\n        assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n        const { basePath, loose, patterns } = this;\n\n        if (newBasePath === basePath) {\n            return patterns;\n        }\n        const prefix = `/${relative(newBasePath, basePath)}`;\n\n        return patterns.map(pattern => {\n            const negative = pattern.startsWith(\"!\");\n            const head = negative ? \"!\" : \"\";\n            const body = negative ? pattern.slice(1) : pattern;\n\n            if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n                return `${head}${prefix}${body}`;\n            }\n            return loose ? pattern : `${head}${prefix}/**/${body}`;\n        });\n    }\n}\n\nexport { IgnorePattern };\n","/**\n * @fileoverview `ExtractedConfig` class.\n *\n * `ExtractedConfig` class expresses a final configuration for a specific file.\n *\n * It provides one method.\n *\n * - `toCompatibleObjectAsConfigFileContent()`\n *      Convert this configuration to the compatible object as the content of\n *      config files. It converts the loaded parser and plugins to strings.\n *      `CLIEngine#getConfigForFile(filePath)` method uses this method.\n *\n * `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport { IgnorePattern } from \"./ignore-pattern.js\";\n\n// For VSCode intellisense\n/** @typedef {import(\"../../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").SeverityConf} SeverityConf */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n\n/**\n * Check if `xs` starts with `ys`.\n * @template T\n * @param {T[]} xs The array to check.\n * @param {T[]} ys The array that may be the first part of `xs`.\n * @returns {boolean} `true` if `xs` starts with `ys`.\n */\nfunction startsWith(xs, ys) {\n    return xs.length >= ys.length && ys.every((y, i) => y === xs[i]);\n}\n\n/**\n * The class for extracted config data.\n */\nclass ExtractedConfig {\n    constructor() {\n\n        /**\n         * The config name what `noInlineConfig` setting came from.\n         * @type {string}\n         */\n        this.configNameOfNoInlineConfig = \"\";\n\n        /**\n         * Environments.\n         * @type {Record<string, boolean>}\n         */\n        this.env = {};\n\n        /**\n         * Global variables.\n         * @type {Record<string, GlobalConf>}\n         */\n        this.globals = {};\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {(((filePath:string, dot?:boolean) => boolean) & { basePath:string; patterns:string[] }) | undefined}\n         */\n        this.ignores = void 0;\n\n        /**\n         * The flag that disables directive comments.\n         * @type {boolean|undefined}\n         */\n        this.noInlineConfig = void 0;\n\n        /**\n         * Parser definition.\n         * @type {DependentParser|null}\n         */\n        this.parser = null;\n\n        /**\n         * Options for the parser.\n         * @type {Object}\n         */\n        this.parserOptions = {};\n\n        /**\n         * Plugin definitions.\n         * @type {Record<string, DependentPlugin>}\n         */\n        this.plugins = {};\n\n        /**\n         * Processor ID.\n         * @type {string|null}\n         */\n        this.processor = null;\n\n        /**\n         * The flag that reports unused `eslint-disable` directive comments.\n         * @type {boolean|undefined}\n         */\n        this.reportUnusedDisableDirectives = void 0;\n\n        /**\n         * Rule settings.\n         * @type {Record<string, [SeverityConf, ...any[]]>}\n         */\n        this.rules = {};\n\n        /**\n         * Shared settings.\n         * @type {Object}\n         */\n        this.settings = {};\n    }\n\n    /**\n     * Convert this config to the compatible object as a config file content.\n     * @returns {ConfigData} The converted object.\n     */\n    toCompatibleObjectAsConfigFileContent() {\n        const {\n            /* eslint-disable no-unused-vars */\n            configNameOfNoInlineConfig: _ignore1,\n            processor: _ignore2,\n            /* eslint-enable no-unused-vars */\n            ignores,\n            ...config\n        } = this;\n\n        config.parser = config.parser && config.parser.filePath;\n        config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();\n        config.ignorePatterns = ignores ? ignores.patterns : [];\n\n        // Strip the default patterns from `ignorePatterns`.\n        if (startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {\n            config.ignorePatterns =\n                config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);\n        }\n\n        return config;\n    }\n}\n\nexport { ExtractedConfig };\n","/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport { ExtractedConfig } from \"./extracted-config.js\";\nimport { IgnorePattern } from \"./ignore-pattern.js\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || (filePath && element.criteria.test(filePath))) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n\n    /**\n     * Initialize this error object.\n     * @param {string} pluginId The plugin ID.\n     * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n     */\n    constructor(pluginId, plugins) {\n        super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n        this.messageTemplate = \"plugin-conflict\";\n        this.messageData = { pluginId, plugins };\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        // Adopt the plugin which was found at first.\n        if (targetValue === void 0) {\n            if (sourceValue.error) {\n                throw sourceValue.error;\n            }\n            target[key] = sourceValue;\n        } else if (sourceValue.filePath !== targetValue.filePath) {\n            throw new PluginConflictError(key, [\n                {\n                    filePath: targetValue.filePath,\n                    importerName: targetValue.importerName\n                },\n                {\n                    filePath: sourceValue.filePath,\n                    importerName: sourceValue.importerName\n                }\n            ]);\n        }\n    }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetDef = target[key];\n        const sourceDef = source[key];\n\n        // Adopt the rule config which was found at first.\n        if (targetDef === void 0) {\n            if (Array.isArray(sourceDef)) {\n                target[key] = [...sourceDef];\n            } else {\n                target[key] = [sourceDef];\n            }\n\n        /*\n         * If the first found rule config is severity only and the current rule\n         * config has options, merge the severity and the options.\n         */\n        } else if (\n            targetDef.length === 1 &&\n            Array.isArray(sourceDef) &&\n            sourceDef.length >= 2\n        ) {\n            targetDef.push(...sourceDef.slice(1));\n        }\n    }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n    const config = new ExtractedConfig();\n    const ignorePatterns = [];\n\n    // Merge elements.\n    for (const index of indices) {\n        const element = instance[index];\n\n        // Adopt the parser which was found at first.\n        if (!config.parser && element.parser) {\n            if (element.parser.error) {\n                throw element.parser.error;\n            }\n            config.parser = element.parser;\n        }\n\n        // Adopt the processor which was found at first.\n        if (!config.processor && element.processor) {\n            config.processor = element.processor;\n        }\n\n        // Adopt the noInlineConfig which was found at first.\n        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n            config.noInlineConfig = element.noInlineConfig;\n            config.configNameOfNoInlineConfig = element.name;\n        }\n\n        // Adopt the reportUnusedDisableDirectives which was found at first.\n        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n        }\n\n        // Collect ignorePatterns\n        if (element.ignorePattern) {\n            ignorePatterns.push(element.ignorePattern);\n        }\n\n        // Merge others.\n        mergeWithoutOverwrite(config.env, element.env);\n        mergeWithoutOverwrite(config.globals, element.globals);\n        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n        mergeWithoutOverwrite(config.settings, element.settings);\n        mergePlugins(config.plugins, element.plugins);\n        mergeRuleConfigs(config.rules, element.rules);\n    }\n\n    // Create the predicate function for ignore patterns.\n    if (ignorePatterns.length > 0) {\n        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n    }\n\n    return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n    if (defs) {\n        const prefix = pluginId && `${pluginId}/`;\n\n        for (const [key, value] of Object.entries(defs)) {\n            map.set(\n                `${prefix}${key}`,\n                normalize ? normalize(value) : value\n            );\n        }\n    }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n    return typeof rule === \"function\" ? { create: rule } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n    Object.defineProperties(map, {\n        clear: { configurable: true, value: void 0 },\n        delete: { configurable: true, value: void 0 },\n        set: { configurable: true, value: void 0 }\n    });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n    const processed = new Set();\n\n    slots.envMap = new Map();\n    slots.processorMap = new Map();\n    slots.ruleMap = new Map();\n\n    for (const element of elements) {\n        if (!element.plugins) {\n            continue;\n        }\n\n        for (const [pluginId, value] of Object.entries(element.plugins)) {\n            const plugin = value.definition;\n\n            if (!plugin || processed.has(pluginId)) {\n                continue;\n            }\n            processed.add(pluginId);\n\n            collect(pluginId, plugin.environments, slots.envMap);\n            collect(pluginId, plugin.processors, slots.processorMap);\n            collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n        }\n    }\n\n    deleteMutationMethods(slots.envMap);\n    deleteMutationMethods(slots.processorMap);\n    deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n    const slots = internalSlotsMap.get(instance);\n\n    if (!slots.ruleMap) {\n        initPluginMemberMaps(instance, slots);\n    }\n\n    return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n\n    /**\n     * Get the plugin environments.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Environment>} The plugin environments.\n     */\n    get pluginEnvironments() {\n        return ensurePluginMemberMaps(this).envMap;\n    }\n\n    /**\n     * Get the plugin processors.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Processor>} The plugin processors.\n     */\n    get pluginProcessors() {\n        return ensurePluginMemberMaps(this).processorMap;\n    }\n\n    /**\n     * Get the plugin rules.\n     * The returned map cannot be mutated.\n     * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n     */\n    get pluginRules() {\n        return ensurePluginMemberMaps(this).ruleMap;\n    }\n\n    /**\n     * Check if this config has `root` flag.\n     * @returns {boolean} `true` if this config array is root.\n     */\n    isRoot() {\n        for (let i = this.length - 1; i >= 0; --i) {\n            const root = this[i].root;\n\n            if (typeof root === \"boolean\") {\n                return root;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extract the config data which is related to a given file.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {ExtractedConfig} The extracted config data.\n     */\n    extractConfig(filePath) {\n        const { cache } = internalSlotsMap.get(this);\n        const indices = getMatchedIndices(this, filePath);\n        const cacheKey = indices.join(\",\");\n\n        if (!cache.has(cacheKey)) {\n            cache.set(cacheKey, createConfig(this, indices));\n        }\n\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Check if a given path is an additional lint target.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the file is an additional lint target.\n     */\n    isAdditionalTargetPath(filePath) {\n        for (const { criteria, type } of this) {\n            if (\n                type === \"config\" &&\n                criteria &&\n                !criteria.endsWithWildcard &&\n                criteria.test(filePath)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Get the used extracted configs.\n * CLIEngine will use this method to collect used deprecated rules.\n * @param {ConfigArray} instance The config array object to get.\n * @returns {ExtractedConfig[]} The used extracted configs.\n * @private\n */\nfunction getUsedExtractedConfigs(instance) {\n    const { cache } = internalSlotsMap.get(instance);\n\n    return Array.from(cache.values());\n}\n\n\nexport {\n    ConfigArray,\n    getUsedExtractedConfigs\n};\n","/**\n * @fileoverview `ConfigDependency` class.\n *\n * `ConfigDependency` class expresses a loaded parser or plugin.\n *\n * If the parser or plugin was loaded successfully, it has `definition` property\n * and `filePath` property. Otherwise, it has `error` property.\n *\n * When `JSON.stringify()` converted a `ConfigDependency` object to a JSON, it\n * omits `definition` property.\n *\n * `ConfigArrayFactory` creates `ConfigDependency` objects when it loads parsers\n * or plugins.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport util from \"util\";\n\n/**\n * The class is to store parsers or plugins.\n * This class hides the loaded object from `JSON.stringify()` and `console.log`.\n * @template T\n */\nclass ConfigDependency {\n\n    /**\n     * Initialize this instance.\n     * @param {Object} data The dependency data.\n     * @param {T} [data.definition] The dependency if the loading succeeded.\n     * @param {Error} [data.error] The error object if the loading failed.\n     * @param {string} [data.filePath] The actual path to the dependency if the loading succeeded.\n     * @param {string} data.id The ID of this dependency.\n     * @param {string} data.importerName The name of the config file which loads this dependency.\n     * @param {string} data.importerPath The path to the config file which loads this dependency.\n     */\n    constructor({\n        definition = null,\n        error = null,\n        filePath = null,\n        id,\n        importerName,\n        importerPath\n    }) {\n\n        /**\n         * The loaded dependency if the loading succeeded.\n         * @type {T|null}\n         */\n        this.definition = definition;\n\n        /**\n         * The error object if the loading failed.\n         * @type {Error|null}\n         */\n        this.error = error;\n\n        /**\n         * The loaded dependency if the loading succeeded.\n         * @type {string|null}\n         */\n        this.filePath = filePath;\n\n        /**\n         * The ID of this dependency.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The name of the config file which loads this dependency.\n         * @type {string}\n         */\n        this.importerName = importerName;\n\n        /**\n         * The path to the config file which loads this dependency.\n         * @type {string}\n         */\n        this.importerPath = importerPath;\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        const obj = this[util.inspect.custom]();\n\n        // Display `error.message` (`Error#message` is unenumerable).\n        if (obj.error instanceof Error) {\n            obj.error = { ...obj.error, message: obj.error.message };\n        }\n\n        return obj;\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        const {\n            definition: _ignore, // eslint-disable-line no-unused-vars\n            ...obj\n        } = this;\n\n        return obj;\n    }\n}\n\n/** @typedef {ConfigDependency<import(\"../../shared/types\").Parser>} DependentParser */\n/** @typedef {ConfigDependency<import(\"../../shared/types\").Plugin>} DependentPlugin */\n\nexport { ConfigDependency };\n","/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport assert from \"assert\";\nimport path from \"path\";\nimport util from \"util\";\nimport minimatch from \"minimatch\";\n\nconst { Minimatch } = minimatch;\n\nconst minimatchOpts = { dot: true, matchBase: true };\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.filter(Boolean);\n    }\n    if (typeof patterns === \"string\" && patterns) {\n        return [patterns];\n    }\n    return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n    if (patterns.length === 0) {\n        return null;\n    }\n    return patterns.map(pattern => {\n        if (/^\\.[/\\\\]/u.test(pattern)) {\n            return new Minimatch(\n                pattern.slice(2),\n\n                // `./*.js` should not match with `subdir/foo.js`\n                { ...minimatchOpts, matchBase: false }\n            );\n        }\n        return new Minimatch(pattern, minimatchOpts);\n    });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({ includes, excludes }) {\n    return {\n        includes: includes && includes.map(m => m.pattern),\n        excludes: excludes && excludes.map(m => m.pattern)\n    };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n\n    /**\n     * Create a tester with given criteria.\n     * If there are no criteria, returns `null`.\n     * @param {string|string[]} files The glob patterns for included files.\n     * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n     * @param {string} basePath The path to the base directory to test paths.\n     * @returns {OverrideTester|null} The created instance or `null`.\n     */\n    static create(files, excludedFiles, basePath) {\n        const includePatterns = normalizePatterns(files);\n        const excludePatterns = normalizePatterns(excludedFiles);\n        let endsWithWildcard = false;\n\n        if (includePatterns.length === 0) {\n            return null;\n        }\n\n        // Rejects absolute paths or relative paths to parents.\n        for (const pattern of includePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n            if (pattern.endsWith(\"*\")) {\n                endsWithWildcard = true;\n            }\n        }\n        for (const pattern of excludePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        }\n\n        const includes = toMatcher(includePatterns);\n        const excludes = toMatcher(excludePatterns);\n\n        return new OverrideTester(\n            [{ includes, excludes }],\n            basePath,\n            endsWithWildcard\n        );\n    }\n\n    /**\n     * Combine two testers by logical and.\n     * If either of the testers was `null`, returns the other tester.\n     * The `basePath` property of the two must be the same value.\n     * @param {OverrideTester|null} a A tester.\n     * @param {OverrideTester|null} b Another tester.\n     * @returns {OverrideTester|null} Combined tester.\n     */\n    static and(a, b) {\n        if (!b) {\n            return a && new OverrideTester(\n                a.patterns,\n                a.basePath,\n                a.endsWithWildcard\n            );\n        }\n        if (!a) {\n            return new OverrideTester(\n                b.patterns,\n                b.basePath,\n                b.endsWithWildcard\n            );\n        }\n\n        assert.strictEqual(a.basePath, b.basePath);\n        return new OverrideTester(\n            a.patterns.concat(b.patterns),\n            a.basePath,\n            a.endsWithWildcard || b.endsWithWildcard\n        );\n    }\n\n    /**\n     * Initialize this instance.\n     * @param {Pattern[]} patterns The matchers.\n     * @param {string} basePath The base path.\n     * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n     */\n    constructor(patterns, basePath, endsWithWildcard = false) {\n\n        /** @type {Pattern[]} */\n        this.patterns = patterns;\n\n        /** @type {string} */\n        this.basePath = basePath;\n\n        /** @type {boolean} */\n        this.endsWithWildcard = endsWithWildcard;\n    }\n\n    /**\n     * Test if a given path is matched or not.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the path was matched.\n     */\n    test(filePath) {\n        if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n            throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n        }\n        const relativePath = path.relative(this.basePath, filePath);\n\n        return this.patterns.every(({ includes, excludes }) => (\n            (!includes || includes.some(m => m.match(relativePath))) &&\n            (!excludes || !excludes.some(m => m.match(relativePath)))\n        ));\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        if (this.patterns.length === 1) {\n            return {\n                ...patternToJson(this.patterns[0]),\n                basePath: this.basePath\n            };\n        }\n        return {\n            AND: this.patterns.map(patternToJson),\n            basePath: this.basePath\n        };\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        return this.toJSON();\n    }\n}\n\nexport { OverrideTester };\n","/**\n * @fileoverview `ConfigArray` class.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport { ConfigArray, getUsedExtractedConfigs } from \"./config-array.js\";\nimport { ConfigDependency } from \"./config-dependency.js\";\nimport { ExtractedConfig } from \"./extracted-config.js\";\nimport { IgnorePattern } from \"./ignore-pattern.js\";\nimport { OverrideTester } from \"./override-tester.js\";\n\nexport {\n    ConfigArray,\n    ConfigDependency,\n    ExtractedConfig,\n    IgnorePattern,\n    OverrideTester,\n    getUsedExtractedConfigs\n};\n","/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Normalizes the severity value of a rule's configuration to a number\n * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally\n * received from the user. A valid config value is either 0, 1, 2, the string \"off\" (treated the same as 0),\n * the string \"warn\" (treated the same as 1), the string \"error\" (treated the same as 2), or an array\n * whose first element is one of the above values. Strings are matched case-insensitively.\n * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.\n */\nfunction getRuleSeverity(ruleConfig) {\n    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {\n        return severityValue;\n    }\n\n    if (typeof severityValue === \"string\") {\n        return RULE_SEVERITY[severityValue.toLowerCase()] || 0;\n    }\n\n    return 0;\n}\n\n/**\n * Converts old-style severity settings (0, 1, 2) into new-style\n * severity settings (off, warn, error) for all rules. Assumption is that severity\n * values have already been validated as correct.\n * @param {Object} config The config object to normalize.\n * @returns {void}\n */\nfunction normalizeToStrings(config) {\n\n    if (config.rules) {\n        Object.keys(config.rules).forEach(ruleId => {\n            const ruleConfig = config.rules[ruleId];\n\n            if (typeof ruleConfig === \"number\") {\n                config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n            } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n            }\n        });\n    }\n}\n\n/**\n * Determines if the severity for the given rule configuration represents an error.\n * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n * @returns {boolean} True if the rule represents an error, false if not.\n */\nfunction isErrorSeverity(ruleConfig) {\n    return getRuleSeverity(ruleConfig) === 2;\n}\n\n/**\n * Checks whether a given config has valid severity or not.\n * @param {number|string|Array} ruleConfig The configuration for an individual rule.\n * @returns {boolean} `true` if the configuration has valid severity.\n */\nfunction isValidSeverity(ruleConfig) {\n    let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n    if (typeof severity === \"string\") {\n        severity = severity.toLowerCase();\n    }\n    return VALID_SEVERITIES.indexOf(severity) !== -1;\n}\n\n/**\n * Checks whether every rule of a given config has valid severity or not.\n * @param {Object} config The configuration for rules.\n * @returns {boolean} `true` if the configuration has valid severity.\n */\nfunction isEverySeverityValid(config) {\n    return Object.keys(config).every(ruleId => isValidSeverity(config[ruleId]));\n}\n\n/**\n * Normalizes a value for a global in a config\n * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n * a global directive comment\n * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n * @throws Error if global value is invalid\n */\nfunction normalizeConfigGlobal(configuredValue) {\n    switch (configuredValue) {\n        case \"off\":\n            return \"off\";\n\n        case true:\n        case \"true\":\n        case \"writeable\":\n        case \"writable\":\n            return \"writable\";\n\n        case null:\n        case false:\n        case \"false\":\n        case \"readable\":\n        case \"readonly\":\n            return \"readonly\";\n\n        default:\n            throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n    }\n}\n\nexport {\n    getRuleSeverity,\n    normalizeToStrings,\n    isErrorSeverity,\n    isValidSeverity,\n    isEverySeverityValid,\n    normalizeConfigGlobal\n};\n","/**\n * @fileoverview Provide the function that emits deprecation warnings.\n * @author Toru Nagashima <http://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport path from \"path\";\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n// Defitions for deprecation warnings.\nconst deprecationWarningMessages = {\n    ESLINT_LEGACY_ECMAFEATURES:\n        \"The 'ecmaFeatures' config file property is deprecated and has no effect.\",\n    ESLINT_PERSONAL_CONFIG_LOAD:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please use a config file per project or the '--config' option.\",\n    ESLINT_PERSONAL_CONFIG_SUPPRESS:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please remove it or add 'root:true' to the config files in your \" +\n        \"projects in order to avoid loading '~/.eslintrc.*' accidentally.\"\n};\n\nconst sourceFileErrorCache = new Set();\n\n/**\n * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted\n * for each unique file path, but repeated invocations with the same file path have no effect.\n * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.\n * @param {string} source The name of the configuration source to report the warning for.\n * @param {string} errorCode The warning message to show.\n * @returns {void}\n */\nfunction emitDeprecationWarning(source, errorCode) {\n    const cacheKey = JSON.stringify({ source, errorCode });\n\n    if (sourceFileErrorCache.has(cacheKey)) {\n        return;\n    }\n    sourceFileErrorCache.add(cacheKey);\n\n    const rel = path.relative(process.cwd(), source);\n    const message = deprecationWarningMessages[errorCode];\n\n    process.emitWarning(\n        `${message} (found in \"${rel}\")`,\n        \"DeprecationWarning\",\n        errorCode\n    );\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport {\n    emitDeprecationWarning\n};\n","/**\n * @fileoverview The instance of Ajv validator.\n * @author Evgeny Poberezkin\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport Ajv from \"ajv\";\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/*\n * Copied from ajv/lib/refs/json-schema-draft-04.json\n * The MIT License (MIT)\n * Copyright (c) 2015-2017 Evgeny Poberezkin\n */\nconst metaSchema = {\n    id: \"http://json-schema.org/draft-04/schema#\",\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    description: \"Core schema meta-schema\",\n    definitions: {\n        schemaArray: {\n            type: \"array\",\n            minItems: 1,\n            items: { $ref: \"#\" }\n        },\n        positiveInteger: {\n            type: \"integer\",\n            minimum: 0\n        },\n        positiveIntegerDefault0: {\n            allOf: [{ $ref: \"#/definitions/positiveInteger\" }, { default: 0 }]\n        },\n        simpleTypes: {\n            enum: [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n        },\n        stringArray: {\n            type: \"array\",\n            items: { type: \"string\" },\n            minItems: 1,\n            uniqueItems: true\n        }\n    },\n    type: \"object\",\n    properties: {\n        id: {\n            type: \"string\"\n        },\n        $schema: {\n            type: \"string\"\n        },\n        title: {\n            type: \"string\"\n        },\n        description: {\n            type: \"string\"\n        },\n        default: { },\n        multipleOf: {\n            type: \"number\",\n            minimum: 0,\n            exclusiveMinimum: true\n        },\n        maximum: {\n            type: \"number\"\n        },\n        exclusiveMaximum: {\n            type: \"boolean\",\n            default: false\n        },\n        minimum: {\n            type: \"number\"\n        },\n        exclusiveMinimum: {\n            type: \"boolean\",\n            default: false\n        },\n        maxLength: { $ref: \"#/definitions/positiveInteger\" },\n        minLength: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        pattern: {\n            type: \"string\",\n            format: \"regex\"\n        },\n        additionalItems: {\n            anyOf: [\n                { type: \"boolean\" },\n                { $ref: \"#\" }\n            ],\n            default: { }\n        },\n        items: {\n            anyOf: [\n                { $ref: \"#\" },\n                { $ref: \"#/definitions/schemaArray\" }\n            ],\n            default: { }\n        },\n        maxItems: { $ref: \"#/definitions/positiveInteger\" },\n        minItems: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        uniqueItems: {\n            type: \"boolean\",\n            default: false\n        },\n        maxProperties: { $ref: \"#/definitions/positiveInteger\" },\n        minProperties: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        required: { $ref: \"#/definitions/stringArray\" },\n        additionalProperties: {\n            anyOf: [\n                { type: \"boolean\" },\n                { $ref: \"#\" }\n            ],\n            default: { }\n        },\n        definitions: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        properties: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        patternProperties: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        dependencies: {\n            type: \"object\",\n            additionalProperties: {\n                anyOf: [\n                    { $ref: \"#\" },\n                    { $ref: \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        enum: {\n            type: \"array\",\n            minItems: 1,\n            uniqueItems: true\n        },\n        type: {\n            anyOf: [\n                { $ref: \"#/definitions/simpleTypes\" },\n                {\n                    type: \"array\",\n                    items: { $ref: \"#/definitions/simpleTypes\" },\n                    minItems: 1,\n                    uniqueItems: true\n                }\n            ]\n        },\n        format: { type: \"string\" },\n        allOf: { $ref: \"#/definitions/schemaArray\" },\n        anyOf: { $ref: \"#/definitions/schemaArray\" },\n        oneOf: { $ref: \"#/definitions/schemaArray\" },\n        not: { $ref: \"#\" }\n    },\n    dependencies: {\n        exclusiveMaximum: [\"maximum\"],\n        exclusiveMinimum: [\"minimum\"]\n    },\n    default: { }\n};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport default (additionalOptions = {}) => {\n    const ajv = new Ajv({\n        meta: false,\n        useDefaults: true,\n        validateSchema: false,\n        missingRefs: \"ignore\",\n        verbose: true,\n        schemaId: \"auto\",\n        ...additionalOptions\n    });\n\n    ajv.addMetaSchema(metaSchema);\n    // eslint-disable-next-line no-underscore-dangle\n    ajv._opts.defaultMeta = metaSchema.id;\n\n    return ajv;\n};\n","/**\n * @fileoverview Defines a schema for configs.\n * @author Sylvan Mably\n */\n\nconst baseConfigProperties = {\n    $schema: { type: \"string\" },\n    env: { type: \"object\" },\n    extends: { $ref: \"#/definitions/stringOrStrings\" },\n    globals: { type: \"object\" },\n    overrides: {\n        type: \"array\",\n        items: { $ref: \"#/definitions/overrideConfig\" },\n        additionalItems: false\n    },\n    parser: { type: [\"string\", \"null\"] },\n    parserOptions: { type: \"object\" },\n    plugins: { type: \"array\" },\n    processor: { type: \"string\" },\n    rules: { type: \"object\" },\n    settings: { type: \"object\" },\n    noInlineConfig: { type: \"boolean\" },\n    reportUnusedDisableDirectives: { type: \"boolean\" },\n\n    ecmaFeatures: { type: \"object\" } // deprecated; logs a warning when used\n};\n\nconst configSchema = {\n    definitions: {\n        stringOrStrings: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false\n                }\n            ]\n        },\n        stringOrStringsRequired: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false,\n                    minItems: 1\n                }\n            ]\n        },\n\n        // Config at top-level.\n        objectConfig: {\n            type: \"object\",\n            properties: {\n                root: { type: \"boolean\" },\n                ignorePatterns: { $ref: \"#/definitions/stringOrStrings\" },\n                ...baseConfigProperties\n            },\n            additionalProperties: false\n        },\n\n        // Config in `overrides`.\n        overrideConfig: {\n            type: \"object\",\n            properties: {\n                excludedFiles: { $ref: \"#/definitions/stringOrStrings\" },\n                files: { $ref: \"#/definitions/stringOrStringsRequired\" },\n                ...baseConfigProperties\n            },\n            required: [\"files\"],\n            additionalProperties: false\n        }\n    },\n\n    $ref: \"#/definitions/objectConfig\"\n};\n\nexport default configSchema;\n","/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport globals from \"globals\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the object that has difference.\n * @param {Record<string,boolean>} current The newer object.\n * @param {Record<string,boolean>} prev The older object.\n * @returns {Record<string,boolean>} The difference object.\n */\nfunction getDiff(current, prev) {\n    const retv = {};\n\n    for (const [key, value] of Object.entries(current)) {\n        if (!Object.hasOwnProperty.call(prev, key)) {\n            retv[key] = value;\n        }\n    }\n\n    return retv;\n}\n\nconst newGlobals2015 = getDiff(globals.es2015, globals.es5); // 19 variables such as Promise, Map, ...\nconst newGlobals2017 = {\n    Atomics: false,\n    SharedArrayBuffer: false\n};\nconst newGlobals2020 = {\n    BigInt: false,\n    BigInt64Array: false,\n    BigUint64Array: false,\n    globalThis: false\n};\n\nconst newGlobals2021 = {\n    AggregateError: false,\n    FinalizationRegistry: false,\n    WeakRef: false\n};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/** @type {Map<string, import(\"../lib/shared/types\").Environment>} */\nexport default new Map(Object.entries({\n\n    // Language\n    builtin: {\n        globals: globals.es5\n    },\n    es6: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2015: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2016: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 7\n        }\n    },\n    es2017: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 8\n        }\n    },\n    es2018: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 9\n        }\n    },\n    es2019: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 10\n        }\n    },\n    es2020: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },\n        parserOptions: {\n            ecmaVersion: 11\n        }\n    },\n    es2021: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },\n        parserOptions: {\n            ecmaVersion: 12\n        }\n    },\n    es2022: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },\n        parserOptions: {\n            ecmaVersion: 13\n        }\n    },\n\n    // Platforms\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n\n    // Frameworks\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n}));\n","/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n/* eslint class-methods-use-this: \"off\" */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport util from \"util\";\nimport * as ConfigOps from \"./config-ops.js\";\nimport { emitDeprecationWarning } from \"./deprecation-warnings.js\";\nimport ajvOrig from \"./ajv.js\";\nimport configSchema from \"../../conf/config-schema.js\";\nimport BuiltInEnvironments from \"../../conf/environments.js\";\n\nconst ajv = ajvOrig();\n\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\nconst validated = new WeakSet();\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nexport default class ConfigValidator {\n    constructor({ builtInRules = new Map() } = {}) {\n        this.builtInRules = builtInRules;\n    }\n\n    /**\n     * Gets a complete options schema for a rule.\n     * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n     * @returns {Object} JSON Schema for the rule